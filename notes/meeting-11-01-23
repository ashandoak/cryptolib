# Crypto formal proofs meeting
## Jan. 11, 2023

  - Should be randomness in all commitments.lean algorithms
  - To prove perfect hiding need to argue randomness covers anything
  - Binding: Commitment can only be opened to one value (single solution to a formula)
    - So perfect binding should be easy - but Pedersen doesn't use perfect binding
  - Could Lean prove that both perfect binding and perfect hiding is possible: If there is one solution then then there is only one way to open it, but this contradicts perfect hiding - which says that for every message there should be some randomness in the algorithm
  - Need an abstract definition of all: Perfect should imply computational if we've done a good job with definitions
    - Unbounded adversary is effectively the same as universal quantifiers
  - Might be nice to show the definition implications (as referenced above)
  - Lupo: Sweeps computational under the rug
  - Hybrid argument: Multiple steps are indistinguishable and adversary is implicitly there
    - Suppose A can solve step one, then A can solve final step, then clearly A can solve middle steps
  - CDH or DDH vs DL for reduction? - Probably can't *cheat* and do a lazy proof:
    - i.e. using DDH to randomize terms
    - Instead of A, make everything indistinguishable from uniformly random
    - ... but would still need DL in the end
  - Perfect hiding is some property:
    - Lupo: Output space of the commitment is uniform over a group
    - For a fixed output there are equal possibilities of message and randomness
    - For every m there is exactly one r that gives c
    - For encryption you might want uniform - but technically that's not what encryption says.
  - Security parameter: Modify Gen to accept security parameter (for elgamal a group, otherwise security space) - typically abstracted out because not always nice groups to handle it. In Lean, maybe just assume prime order group of a certain minimal size.
  - Interesting exercise: Is there a reduction that is not advantage preserving (elgamal is advantage preserving)
  - SIS hash: Pick module q over Z pick big matrix (500 x 10000) pick binary vector n = 10000 and hash with matrix - this is collision resistant. Simple reduction. 
  - Good first step: Perfectly hiding => computation hiding and perfectly binding => computational binding (security parameter - generally necessary, but maybe not for these proofs? Worth including)
    - Gen -> public parameters, assume security parameters is implicit (even when people are being highly formal)
    - Can be included, but really not necessary
    - Gen should accept implicit security parameter; in group scenario we assume a group of the appropriate size
    - Hyper formal: negligible would output a parameter in the security parameter - makes more sense if considering concrete security parameter
  - Possible steps: What do *most* reductions do?
    - Ours is a non-adaptive reduction - but an adaptive would be based on changing reduction based on query based on last step -> i.e. there is some way to reason between queries